<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Disfluency Annotation Experiment – Final Version</title>
  <style>
    /* Global Styles */
    body {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      background-color: #ffffff;
      transition: background-color 0.5s ease;
    }
    /* Start Page */
    #start-page {
      text-align: center;
      padding: 50px;
    }
    #start-page input[type="text"],
    #start-page input[type="number"] {
      padding: 10px;
      font-size: 16px;
      width: 300px;
      margin: 10px 0;
    }
    #start-page label {
      font-size: 16px;
      margin: 5px 0;
      display: block;
    }
    #start-page button {
      padding: 10px 15px;
      font-size: 16px;
      cursor: pointer;
      margin-top: 15px;
    }
    /* Saved Progress Section */
    #saved-progress-section {
      margin-top: 20px;
    }
    /* Experiment Page */
    #experiment-page {
      display: none;
      max-width: 1200px;
      margin: auto;
      padding: 20px;
    }
    #instructions {
      margin-bottom: 20px;
      padding: 15px;
      background-color: #f5f5f5;
      border: 1px solid #ccc;
      font-size: 18px;
    }
    #file-id {
      font-size: 20px;
      margin-bottom: 10px;
    }
    /* Delay Control Panel on Experiment Page */
    #delay-panel {
      text-align: center;
      margin-bottom: 15px;
    }
    #delay-panel input[type="number"] {
      width: 80px;
      padding: 5px;
      font-size: 16px;
    }
    /* Waveform Block */
    #waveform {
      position: relative;
      width: 100%;
      height: 200px;
      background: #f2f2f2;
      border: 1px solid #ccc;
      pointer-events: none;
      user-select: none;
      margin-bottom: 15px;
    }
    #cursor {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 2px;
      background: red;
      pointer-events: none;
    }
    /* Overlay for Annotation */
    #draw-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none; /* enabled in editing mode */
    }
    /* Container for word overlays on waveform */
    #word-overlays {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    /* Editing Mode Control Panel */
    #edit-mode-panel {
      margin: 10px 0;
      display: none;
      text-align: center;
    }
    #edit-mode-panel label {
      margin: 0 10px;
      font-size: 16px;
    }
    /* Annotation (Textgrid) Block */
    #annotation-block {
      margin-bottom: 15px;
      padding: 10px;
      border: 1px solid #ddd;
      background: #f9f9f9;
    }
    #annotation-block h3 {
      margin: 0;
      padding: 5px;
      background: #eee;
      font-size: 16px;
    }
    #editor-content {
      position: relative;
      height: 80px;
      width: 100%;
      pointer-events: none; /* non-interactive in Phase 1 */
    }
    /* Textgrid Result Block (with timestamps) */
    #textgrid-result {
      margin-top: 15px;
      padding: 10px;
      border: 1px solid #ddd;
      background: #fcfcfc;
      font-family: monospace;
      font-size: 14px;
      display: none;  /* Only shown after audio finishes */
    }
    /* Confirm Block */
    #confirm-block {
      text-align: center;
      margin-top: 15px;
      display: none; /* Only shown after audio finishes or editing */
    }
    /* Navigation Block */
    #navigation {
      text-align: center;
      margin-top: 20px;
    }
    /* Large Button Styles */
    .large-btn {
      font-size: 20px;
      padding: 15px 25px;
      margin: 10px;
      cursor: pointer;
      border: none;
      border-radius: 4px;
      transition: background-color 0.3s ease;
    }
    .large-btn:hover {
      background-color: #ffcc00;
    }
    /* Specific Button Colors */
    #annotate-button {
      background-color: #009688;
      color: #fff;
    }
    #annotate-button:hover {
      background-color: #00796b;
    }
    #edit-annotations-button {
      background-color: #3f51b5;
      color: #fff;
    }
    #edit-annotations-button:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }
    #edit-annotations-button:hover:disabled {
      background-color: #ccc;
    }
    #confirm-button {
      background-color: #4caf50;
      color: #fff;
    }
    #confirm-button:hover {
      background-color: #388e3c;
    }
    #prev-page, #next-page {
      background-color: #4caf50;
      color: #fff;
    }
    #prev-page:hover, #next-page:hover {
      background-color: #388e3c;
    }
    /* Disabled navigation buttons */
    #prev-page:disabled, #next-page:disabled {
      background-color: #ccc;
      color: #666;
      cursor: not-allowed;
    }
    /* Word boxes in Textgrid: clickable only in editing mode */
    .word {
      position: absolute;
      top: 0;
      bottom: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      white-space: nowrap;
      font-size: 14px;
      box-sizing: border-box;
      background-color: white;
      color: #37474F;
      transition: background-color 0.2s ease, border 0.2s ease;
      cursor: pointer;
    }
    .word.highlight {
      background-color: #FFF3E0 !important;
      color: #BF360C;
      font-weight: bold;
      border: 1px solid #333;
    }
    /* Overlay for toggled words on waveform */
    .word-overlay {
      position: absolute;
      top: 0;
      height: 100%;
      background-color: rgba(255, 200, 0, 0.3);
      pointer-events: none;
    }
    /* Annotation interval overlays */
    .annotation-overlay {
      position: absolute;
      top: 0;
      height: 100%;
      pointer-events: auto;
    }
  </style>
</head>
<body>
  <!-- Start Page -->
  <div id="start-page">
    <h1>Disfluency Annotation Experiment</h1>
    <p>Please enter your name to begin:</p>
    <input type="text" id="rater-name" placeholder="Your Name">
    <br>
    <!-- Extra Option: Delay (in seconds) -->
    <label>
      Delay (sec; default 0.3):
      <input type="number" id="delay-input" value="0.3" step="0.1" min="0">
    </label>
    <!-- Options -->
    <label><input type="checkbox" id="toggle-method-labels"> Show Method Labels</label>
    <label><input type="checkbox" id="shuffle-methods"> Shuffle Methods</label>
    <label>
      Methods to evaluate (comma-separated; leave blank for all):
      <input type="text" id="selected-methods" placeholder="e.g. ground, att_based_D_on_src, zs_hs_based_D_on_src">
    </label>
    <br>
    <!-- Saved Progress -->
    <div id="saved-progress-section" style="display: none;">
      <p>You have saved progress. Would you like to continue where you left off?</p>
      <button id="continue-saved">Continue Saved Experiment</button>
      <button id="start-new">Start New Experiment</button>
    </div>
    <button id="start-experiment">Start Experiment</button>
  </div>
  
  <!-- Experiment Page -->
  <div id="experiment-page">
    <p>
      <strong>Step 1:</strong> Play the audio and <em>click & hold</em> the "Annotate" button to mark your annotation while listening.
    </p>
    <p style="color: red;">
      (A delay of <span id="display-delay">0.3</span> sec is applied.)
    </p>
    <p>
      <strong>Step 2:</strong> When the audio is finished (and after the delay), your annotation and a textgrid (with timestamps) will be displayed.
    </p>
    <p>
      <strong>Step 3.1:</strong> If you are satisfied, click the <strong>Confirm</strong> button (the Next button remains inactive until Confirm is clicked).
    </p>
    <p>
      <strong>Step 3.2:</strong> If not, click <strong>Start Editing</strong> to adjust your annotation. In editing mode, you can choose among three modes:
    </p>
    <ul style="text-align: left;">
      <li>
        <strong>Add mode:</strong> Add segments (for example, if a word seems to be cut off because it ended too soon, you can add it back).
      </li>
      <li>
        <strong>Erase mode:</strong> Remove mis‐added intervals by clicking them.
      </li>
      <li>
        <strong>Slide mode:</strong> Shift all intervals holistically. (This will update your default delay.)
      </li>
    </ul>
    <p>
      <strong>
        NOTE:
      </strong>
      A text sequence will be provided to help you locate which word you do not understand. 
      <p>
      However, we <strong style="color:red;"> DO NOT</strong> guarantee that the word always corresponds to the waveform.
      </p>
    </p>
    <p>
        If misalignment occurs, please focus on the  <strong style="color:red;">WAVEFORM INTERVAL</strong> believe is unintelligible—even if the text sequence does not show the corresponding annotation.
    </p>
    <p>
      <strong>Step 4:</strong> Click Next for the next annotation.
    </p>
    <p>
      <strong>Step 5:</strong> After finishing all annotations, click "Finish & Download CSV" to download the CSV file.
    </p>
    <p>
      <strong>Please send this file to: <a href="mailto:kevingenghaopeng@g.ecc.u-tokyo.ac.jp">kevingenghaopeng@g.ecc.u-tokyo.ac.jp</a>.</strong>
    </p>
    
    <!-- File Info and Delay Control -->
    <div id="file-id"></div>
    <div id="delay-panel">
      Adjust Delay (sec):
      <input type="number" id="edit-delay-input" value="0.3" step="0.1" min="0">
      <span>(Current: <span id="current-delay">0.30</span> sec)</span>
    </div>
    
    <!-- Waveform Block -->
    <div id="waveform">
      <div id="cursor"></div>
      <div id="draw-overlay">
        <!-- Word overlays will be appended here -->
        <div id="word-overlays"></div>
      </div>
    </div>
    <!-- Control Block -->
    <div id="controls" style="text-align: center;">
      <button id="annotate-button" class="large-btn">Click & Hold to Annotate</button>
      <button id="edit-annotations-button" class="large-btn" disabled>Start Editing</button>
    </div>
    <!-- Editing Mode Control Panel -->
    <div id="edit-mode-panel">
      <label><input type="radio" name="edit-mode" value="add" checked> Add Mode</label>
      <label><input type="radio" name="edit-mode" value="erase"> Erase Mode</label>
      <label><input type="radio" name="edit-mode" value="slide"> Slide Mode</label>
    </div>
    <!-- Confirm Block -->
    <div id="confirm-block" style="text-align: center; display: none;">
      <button id="confirm-button" class="large-btn">Confirm</button>
    </div>
    <!-- Annotation (Textgrid) Block -->
    <div id="annotation-block">
      <h3>Your Annotation</h3>
      <div id="editor-content"></div>
    </div>
    <!-- Textgrid Result Block (with timestamps) -->
    <div id="textgrid-result"></div>
    <!-- Navigation Block -->
    <div id="navigation">
      <button id="prev-page" class="large-btn">Previous</button>
      <span id="page-info"></span>
      <button id="next-page" class="large-btn" disabled>Next</button>
    </div>
    <div style="text-align: center;">
      <button id="save-result" class="large-btn">Save Result (CSV)</button>
      <button id="finish-button" class="large-btn">Finish & Download CSV</button>
    </div>
    <!-- Results Section for Predicted Tiers (if needed) -->
    <div id="results" style="display:none;">
      <h2>Annotation Results</h2>
      <div id="predicted-tiers"></div>
    </div>
  </div>
  
  <!-- Wavesurfer Library -->
  <script src="https://unpkg.com/wavesurfer.js@5.2.0/dist/wavesurfer.min.js"></script>
  <script>
    /***********************
     * Load File IDs and Method List
     ***********************/
    const audioDir = "./wav/V000_R_max_valid/";
    const jsonDir = "./json/disfluency_word_level_res/";
    let idList = [];
    fetch("./wav/output_part_3.scp")
      .then(response => {
        if (!response.ok) throw new Error("Error loading test.scp: " + response.statusText);
        return response.text();
      })
      .then(text => {
        idList = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
        console.log("Loaded idList:", idList);
      })
      .catch(err => console.error(err));
    
    let globalMethodList = [];
    fetch("wav/methods.list")
      .then(response => {
        if (!response.ok) throw new Error("Error loading methods.list: " + response.statusText);
        return response.text();
      })
      .then(text => {
        globalMethodList = text.split(/\r?\n|,/).map(l => l.trim()).filter(Boolean);
        console.log("Loaded Methods:", globalMethodList);
      })
      .catch(err => console.error(err));
    
    /***********************
     * GLOBAL VARIABLES
     ***********************/
    let currentIndex = 0;
    let currentJsonData = null;
    let raterName = "";
    // Global delay (in seconds)
    let delay = 0.3;
    // Use one array for all recorded intervals (each interval: {start, end})
    let recordedIntervals = [];
    // Per-word annotation flags (true = annotated)
    let userWordAnnotationFlags = [];
    // Object to store results for each file
    let resultsPerFile = {};
    
    // Global settings from start page.
    let globalShowMethodLabels = false;
    let globalShuffleMethods = false;
    let globalSelectedMethods = null;
    
    // Editing mode flag & type ("add", "erase", "slide")
    let isEditing = false;
    let currentEditMode = "add";  // default editing mode
    
    const STORAGE_KEY = "disfluencyProgress";
    
    /***********************
     * WAVESURFER SETUP
     ***********************/
    const wavesurfer = WaveSurfer.create({
      container: '#waveform',
      waveColor: '#ddd',
      progressColor: '#a0a0a0',
      height: 200,
      backend: 'WebAudio',
      responsive: true
    });
    const cursor = document.getElementById('cursor');
    wavesurfer.on('audioprocess', currentTime => {
      const duration = wavesurfer.getDuration();
      const containerWidth = wavesurfer.drawer.wrapper.clientWidth;
      cursor.style.left = ((currentTime / duration) * containerWidth) + 'px';
    });
    
    window.addEventListener('keydown', e => {
      if (e.code === "Space" || e.key === " ") {
        e.preventDefault();
        wavesurfer.playPause();
      }
    });
    
    /***********************
     * Start Page Interaction
     ***********************/
    window.addEventListener('load', () => {
      // Update display of delay value
      document.getElementById('display-delay').textContent = delay.toFixed(2);
      document.getElementById('edit-delay-input').value = delay.toFixed(2);
      
      if (localStorage.getItem(STORAGE_KEY)) {
        document.getElementById('saved-progress-section').style.display = 'block';
        document.getElementById('start-experiment').style.display = 'none';
      } else {
        document.getElementById('saved-progress-section').style.display = 'none';
        document.getElementById('start-experiment').style.display = 'inline-block';
      }
    });
    
    document.getElementById('start-new').addEventListener('click', () => {
      localStorage.removeItem(STORAGE_KEY);
      document.getElementById('saved-progress-section').style.display = 'none';
      document.getElementById('start-experiment').style.display = 'inline-block';
    });
    
    document.getElementById('continue-saved').addEventListener('click', () => {
      const savedData = JSON.parse(localStorage.getItem(STORAGE_KEY));
      if (savedData) {
        raterName = savedData.raterName;
        currentIndex = savedData.currentIndex;
        resultsPerFile = savedData.resultsPerFile;
        globalShowMethodLabels = savedData.globalShowMethodLabels;
        globalShuffleMethods = savedData.globalShuffleMethods;
        globalSelectedMethods = savedData.globalSelectedMethods;
        delay = savedData.delay || 0.3;
        document.getElementById('rater-name').value = raterName;
        document.getElementById('toggle-method-labels').checked = globalShowMethodLabels;
        document.getElementById('shuffle-methods').checked = globalShuffleMethods;
        document.getElementById('selected-methods').value = globalSelectedMethods ? globalSelectedMethods.join(', ') : "";
        document.getElementById('delay-input').value = delay;
        document.getElementById('display-delay').textContent = delay.toFixed(2);
        document.getElementById('edit-delay-input').value = delay.toFixed(2);
        document.getElementById('current-delay').textContent = delay.toFixed(2);
        document.getElementById('start-page').style.display = 'none';
        document.getElementById('experiment-page').style.display = 'block';
        loadCurrentFile();
      }
    });
    
    document.getElementById('start-experiment').addEventListener('click', () => {
      const nameInput = document.getElementById('rater-name').value.trim();
      if (!nameInput) {
        alert("Please enter your name.");
        return;
      }
      raterName = nameInput;
      globalShowMethodLabels = document.getElementById('toggle-method-labels').checked;
      globalShuffleMethods = document.getElementById('shuffle-methods').checked;
      let methodsInput = document.getElementById('selected-methods').value.trim();
      if (methodsInput !== "") {
        globalSelectedMethods = methodsInput.split(/[\s,]+/).map(s => s.trim()).filter(s => s !== "");
      } else {
        globalSelectedMethods = null;
      }
      // Set delay from input.
      delay = parseFloat(document.getElementById('delay-input').value) || 0.3;
      document.getElementById('display-delay').textContent = delay.toFixed(2);
      document.getElementById('edit-delay-input').value = delay.toFixed(2);
      document.getElementById('current-delay').textContent = delay.toFixed(2);
      
      localStorage.removeItem(STORAGE_KEY);
      document.getElementById('start-page').style.display = 'none';
      document.getElementById('experiment-page').style.display = 'block';
      loadCurrentFile();
    });
    
    /***********************
     * Update delay when user edits it on experiment page
     ***********************/
    document.getElementById('edit-delay-input').addEventListener('change', (e) => {
      let newDelay = parseFloat(e.target.value);
      if (isNaN(newDelay) || newDelay < 0) {
        newDelay = 0;
      }
      delay = newDelay;
      document.getElementById('current-delay').textContent = delay.toFixed(2);
      document.getElementById('display-delay').textContent = delay.toFixed(2);
      console.log("Updated delay to:", delay);
    });
    
    /***********************
     * LOAD CURRENT FILE
     ***********************/
    function loadCurrentFile() {
      // Reset editing state and intervals
      isEditing = false;
      currentEditMode = "add";
      recordedIntervals = [];
      
      const fileId = idList[currentIndex];
      document.getElementById('file-id').textContent = "File ID: " + fileId + "  (Hit Space Bar to Play/Pause)";
      document.getElementById('page-info').textContent = "File " + (currentIndex + 1) + " of " + idList.length;
      document.getElementById('results').style.display = 'none';
      // Clear previous annotation results and textgrid result.
      document.getElementById('textgrid-result').innerHTML = "";
      document.getElementById('textgrid-result').style.display = "none";
      // Clear annotation block content.
      document.getElementById('editor-content').innerHTML = "";
      // Clear draw-overlay content.
      document.getElementById('draw-overlay').innerHTML = "";
      // Re-create word overlays container.
      const wordOverlays = document.createElement('div');
      wordOverlays.id = "word-overlays";
      wordOverlays.style.position = "absolute";
      wordOverlays.style.top = "0";
      wordOverlays.style.left = "0";
      wordOverlays.style.width = "100%";
      wordOverlays.style.height = "100%";
      wordOverlays.style.pointerEvents = "none";
      document.getElementById('draw-overlay').appendChild(wordOverlays);
      
      // Hide editing controls.
      document.getElementById('edit-mode-panel').style.display = "none";
      document.getElementById('edit-annotations-button').textContent = "Start Editing";
      document.getElementById('edit-annotations-button').disabled = true;  // remain disabled until audio finishes
      document.getElementById('draw-overlay').style.pointerEvents = "none";
      // In Phase 1, annotate button is active; textgrid is non-interactive.
      document.getElementById('annotate-button').disabled = false;
      document.getElementById('editor-content').style.pointerEvents = "none";
      document.body.style.backgroundColor = "#ffffff";
      
      // Disable Next button until Confirm is clicked.
      document.getElementById('next-page').disabled = true;
      // Hide the Confirm block.
      document.getElementById('confirm-block').style.display = "none";
      
      // Load JSON.
      fetch(`${jsonDir}${fileId}.json`)
        .then(r => r.ok ? r.json() : Promise.reject("Error loading JSON for " + fileId))
        .then(jsonData => {
          currentJsonData = jsonData;
          console.log("Loaded JSON for", fileId, jsonData);
        })
        .catch(err => {
          console.error(err);
          alert(err);
        });
      
      // Load audio.
      wavesurfer.load(`${audioDir}${fileId}.wav`);
    }
    
    /***********************
     * When Audio Finishes (Phase 1):
     * Display annotation result and, after the delay, show textgrid result.
     * Then, enable Confirm and Edit button.
     ***********************/
    wavesurfer.on('finish', () => {
      // Always display results regardless of whether an annotation interval was recorded.
      displayResults();
      // Wait for the specified delay (in seconds) before showing the textgrid result.
      setTimeout(() => {
        // displayTextgridResult();
        document.getElementById('annotate-button').disabled = true;
        // Show Confirm block.
        document.getElementById('confirm-block').style.display = "block";
        // Enable editing button.
        document.getElementById('edit-annotations-button').disabled = false;
      }, delay * 1000);
    });
    
    /***********************
     * Normal Annotation (Phase 1)
     * Adjust intervals by subtracting the current delay.
     ***********************/
    let annotationStartTime = 0;
    let annotationIntervalID = null;
    let currentOverlay = null;
    
    document.getElementById('annotate-button').addEventListener('mousedown', () => {
      if (isEditing) return;
      // Adjust start time with delay compensation
      annotationStartTime = Math.max(0, wavesurfer.getCurrentTime() - delay);
      currentOverlay = document.createElement('div');
      currentOverlay.className = "annotation-overlay";
      currentOverlay.style.backgroundColor = 'rgba(0, 150, 136, 0.3)';
      currentOverlay.style.border = '1px solid #009688';
      currentOverlay.style.pointerEvents = 'none';
      document.getElementById('draw-overlay').appendChild(currentOverlay);
      annotationIntervalID = setInterval(() => {
        const currentTime = Math.max(0, wavesurfer.getCurrentTime() - delay);
        const dur = wavesurfer.getDuration();
        const wWidth = wavesurfer.drawer.wrapper.clientWidth;
        const startX = (annotationStartTime / dur) * wWidth;
        const currentX = (currentTime / dur) * wWidth;
        currentOverlay.style.left = startX + 'px';
        currentOverlay.style.width = Math.max(0, currentX - startX) + 'px';
      }, 50);
    });
    
    document.getElementById('annotate-button').addEventListener('mouseup', () => {
      if (!currentOverlay) return;
      clearInterval(annotationIntervalID);
      const annotationEndTime = Math.max(0, wavesurfer.getCurrentTime() - delay);
      if (annotationEndTime > annotationStartTime) {
        recordedIntervals.push({ start: annotationStartTime, end: annotationEndTime });
        console.log("Recorded annotation:", { start: annotationStartTime, end: annotationEndTime });
      }
      currentOverlay = null;
    });
    
    document.getElementById('annotate-button').addEventListener('mouseleave', () => {
      if (currentOverlay) {
        clearInterval(annotationIntervalID);
        const annotationEndTime = Math.max(0, wavesurfer.getCurrentTime() - delay);
        if (annotationEndTime > annotationStartTime) {
          recordedIntervals.push({ start: annotationStartTime, end: annotationEndTime });
        }
        currentOverlay = null;
      }
    });
    
    /***********************
     * Editing Mode Toggle (Phase 2)
     ***********************/
    document.getElementById('edit-annotations-button').addEventListener('click', () => {
      isEditing = !isEditing;
      if (isEditing) {
        // Enter editing mode:
        document.getElementById('edit-annotations-button').textContent = "Finish Editing";
        document.getElementById('draw-overlay').style.pointerEvents = "auto";
        document.body.style.backgroundColor = "#e0f7fa";
        // Re-enable annotation button and textgrid interactivity in add mode.
        document.getElementById('annotate-button').disabled = false;
        document.getElementById('editor-content').style.pointerEvents = "auto";
        // Show editing mode controls.
        document.getElementById('edit-mode-panel').style.display = "block";
      } else {
        // Exit editing mode:
        document.getElementById('edit-annotations-button').textContent = "Start Editing";
        document.getElementById('draw-overlay').style.pointerEvents = "none";
        document.body.style.backgroundColor = "#ffffff";
        // Hide editing mode controls.
        document.getElementById('edit-mode-panel').style.display = "none";
        // After finishing editing, re-render the persistent overlays.
        renderRecordedIntervalsOverlays();
        initializeUserWordAnnotations();
        renderUserTier();
        // Disable annotation button and textgrid interactivity.
        document.getElementById('annotate-button').disabled = true;
        document.getElementById('editor-content').style.pointerEvents = "none";
        // Show Confirm block so user can click Confirm to enable Next.
        document.getElementById('confirm-block').style.display = "block";
      }
    });
    
    // Update currentEditMode when user selects an editing mode.
    document.querySelectorAll('input[name="edit-mode"]').forEach(radio => {
      radio.addEventListener('change', (e) => {
        currentEditMode = e.target.value;
        console.log("Editing mode set to:", currentEditMode);
      });
    });
    
    /***********************
     * Editing Mode Drawing on Waveform (Phase 2)
     ***********************/
    const drawOverlay = document.getElementById('draw-overlay');
    let editModeStartX = 0;
    let editModeCurrentOverlay = null;
    let slideIndicator = null;
    
    // For Add mode: similar to normal annotation drawing
    drawOverlay.addEventListener('mousedown', (e) => {
      if (!isEditing) return;
      const overlayRect = drawOverlay.getBoundingClientRect();
      const offsetX = e.pageX - overlayRect.left;
      
      if (currentEditMode === "add") {
        editModeStartX = offsetX;
        editModeCurrentOverlay = document.createElement('div');
        editModeCurrentOverlay.className = "annotation-overlay";
        editModeCurrentOverlay.style.backgroundColor = 'rgba(0, 0, 255, 0.3)';
        editModeCurrentOverlay.style.border = '1px solid blue';
        editModeCurrentOverlay.style.left = editModeStartX + 'px';
        drawOverlay.appendChild(editModeCurrentOverlay);
      } else if (currentEditMode === "slide") {
        // For Slide mode, record starting position and show a temporary indicator.
        editModeStartX = offsetX;
        slideIndicator = document.createElement('div');
        slideIndicator.style.position = 'absolute';
        slideIndicator.style.top = '0';
        slideIndicator.style.height = '100%';
        slideIndicator.style.width = '2px';
        slideIndicator.style.backgroundColor = 'purple';
        slideIndicator.style.left = editModeStartX + 'px';
        drawOverlay.appendChild(slideIndicator);
      }
    });
    
    drawOverlay.addEventListener('mousemove', (e) => {
      if (!isEditing) return;
      const overlayRect = drawOverlay.getBoundingClientRect();
      const currentX = e.pageX - overlayRect.left;
      
      if (currentEditMode === "add" && editModeCurrentOverlay) {
        let width = currentX - editModeStartX;
        if (width >= 0) {
          editModeCurrentOverlay.style.width = width + 'px';
        } else {
          editModeCurrentOverlay.style.left = currentX + 'px';
          editModeCurrentOverlay.style.width = Math.abs(width) + 'px';
        }
      } else if (currentEditMode === "slide" && slideIndicator) {
        // Move the slide indicator with the mouse.
        slideIndicator.style.left = currentX + 'px';
      }
    });
    
    drawOverlay.addEventListener('mouseup', (e) => {
      if (!isEditing) return;
      const overlayRect = drawOverlay.getBoundingClientRect();
      const endX = e.pageX - overlayRect.left;
      const wWidth = wavesurfer.drawer.wrapper.clientWidth;
      const duration = wavesurfer.getDuration();
      
      if (currentEditMode === "add" && editModeCurrentOverlay) {
        let startX = Math.min(editModeStartX, endX);
        let endXCorrect = Math.max(editModeStartX, endX);
        let startTime = (startX / wWidth) * duration;
        let endTime = (endXCorrect / wWidth) * duration;
        recordedIntervals.push({ start: startTime, end: endTime });
        editModeCurrentOverlay = null;
        renderRecordedIntervalsOverlays();
        initializeUserWordAnnotations();
        renderUserTier();
      } else if (currentEditMode === "slide" && slideIndicator) {
        // Calculate time shift based on the difference.
        let deltaX = endX - editModeStartX;
        let deltaTime = (deltaX / wWidth) * duration;
        // Shift all recorded intervals.
        recordedIntervals = recordedIntervals.map(interval => {
          return { start: Math.max(0, interval.start + deltaTime), end: Math.max(0, interval.end + deltaTime) };
        });
        // Update the global delay accordingly.
        delay += deltaTime;
        document.getElementById('edit-delay-input').value = delay.toFixed(2);
        document.getElementById('current-delay').textContent = delay.toFixed(2);
        document.getElementById('display-delay').textContent = delay.toFixed(2);
        slideIndicator.remove();
        slideIndicator = null;
        renderRecordedIntervalsOverlays();
        initializeUserWordAnnotations();
        renderUserTier();
      }
    });
    
    // For Erase mode: allow clicking on an existing overlay to remove it.
    drawOverlay.addEventListener('click', (e) => {
      if (!isEditing || currentEditMode !== "erase") return;
      // Determine click position.
      const overlayRect = drawOverlay.getBoundingClientRect();
      const clickX = e.pageX - overlayRect.left;
      const wWidth = wavesurfer.drawer.wrapper.clientWidth;
      const duration = wavesurfer.getDuration();
      const clickTime = (clickX / wWidth) * duration;
      // Find and remove any interval that contains this time.
      const beforeCount = recordedIntervals.length;
      recordedIntervals = recordedIntervals.filter(interval => !(clickTime >= interval.start && clickTime <= interval.end));
      if (recordedIntervals.length < beforeCount) {
        renderRecordedIntervalsOverlays();
        initializeUserWordAnnotations();
        renderUserTier();
      }
    });
    
    /***********************
     * Render persistent overlays for recorded intervals
     ***********************/
    function renderRecordedIntervalsOverlays() {
      // Clear any overlays (except word overlays).
      const overlaysContainer = document.getElementById('draw-overlay');
      // Remove any child with class "annotation-overlay" (but leave the word overlays container).
      Array.from(overlaysContainer.children).forEach(child => {
        if (child.id !== "word-overlays") {
          child.remove();
        }
      });
      const wWidth = wavesurfer.drawer.wrapper.clientWidth;
      const duration = wavesurfer.getDuration();
      recordedIntervals.forEach(interval => {
        const leftPercent = (interval.start / duration) * 100;
        const widthPercent = ((interval.end - interval.start) / duration) * 100;
        const overlay = document.createElement('div');
        overlay.className = "annotation-overlay";
        // Color it differently to show it is confirmed.
        overlay.style.backgroundColor = 'rgba(0, 150, 136, 0.3)';
        overlay.style.border = '1px solid #009688';
        overlay.style.left = leftPercent + '%';
        overlay.style.width = widthPercent + '%';
        // In erase mode, let overlays be clickable.
        if (isEditing && currentEditMode === "erase") {
          overlay.style.pointerEvents = "auto";
        } else {
          overlay.style.pointerEvents = "none";
        }
        document.getElementById('draw-overlay').appendChild(overlay);
      });
    }
    
    /***********************
     * Per-word Annotation Functions
     ***********************/
    function initializeUserWordAnnotations() {
      const words = currentJsonData.words.sentence;
      const intervals = currentJsonData.words.interval;
      userWordAnnotationFlags = new Array(words.length).fill(false);
      // Use recordedIntervals (which already include any editing adjustments)
      words.forEach((word, i) => {
        const mid = (intervals[i][0] + intervals[i][1]) / 2;
        recordedIntervals.forEach(interval => {
          if (mid >= interval.start && mid <= interval.end) {
            userWordAnnotationFlags[i] = true;
          }
        });
      });
    }
    
    function renderUserTier() {
      const words = currentJsonData.words.sentence;
      const intervals = currentJsonData.words.interval;
      const totalDuration = intervals[intervals.length - 1][1];
      const editorContentDiv = document.getElementById('editor-content');
      editorContentDiv.innerHTML = "";
      
      words.forEach((word, idx) => {
        const intv = intervals[idx];
        const leftPercent = (intv[0] / totalDuration) * 100;
        const widthPercent = ((intv[1] - intv[0]) / totalDuration) * 100;
        const span = document.createElement('div');
        span.classList.add('word');
        span.textContent = word;
        span.style.left = leftPercent + '%';
        span.style.width = widthPercent + '%';
        if (isEditing) {
          span.style.pointerEvents = "auto";
          span.addEventListener('click', function(e) {
            e.stopPropagation();
            toggleWordAnnotation(idx);
          });
        } else {
          span.style.pointerEvents = "none";
        }
        if (userWordAnnotationFlags[idx]) {
          span.classList.add('highlight');
        }
        editorContentDiv.appendChild(span);
      });
    }
    
    function toggleWordAnnotation(index) {
      if (!isEditing) return;
      userWordAnnotationFlags[index] = !userWordAnnotationFlags[index];
      renderUserTier();
      updateWaveformWordOverlays();
    }
    
    function updateWaveformWordOverlays() {
      const overlaysContainer = document.getElementById('word-overlays');
      overlaysContainer.innerHTML = "";
      const intervals = currentJsonData.words.interval;
      const totalDuration = intervals[intervals.length - 1][1];
      
      userWordAnnotationFlags.forEach((flag, idx) => {
        if (flag) {
          const wordInterval = intervals[idx];
          const leftPercent = (wordInterval[0] / totalDuration) * 100;
          const widthPercent = ((wordInterval[1] - wordInterval[0]) / totalDuration) * 100;
          const overlay = document.createElement('div');
          overlay.classList.add('word-overlay');
          overlay.style.left = leftPercent + '%';
          overlay.style.width = widthPercent + '%';
          overlaysContainer.appendChild(overlay);
        }
      });
    }
    
    function createUserTier(words, intervals, totalDuration) {
      initializeUserWordAnnotations();
      renderUserTier();
      updateWaveformWordOverlays();
    }
    
    /***********************
     * Display Results and Textgrid Result
     ***********************/
    function displayResults() {
      const words = currentJsonData.words.sentence;
      const groundIntervals = currentJsonData.words.interval;
      const totalDuration = groundIntervals[groundIntervals.length - 1][1];
      createUserTier(words, groundIntervals, totalDuration);
      // Optionally, you could call displayTextgridResult() here as well.
    }
    
    // Display a JSON-like textgrid result after play is done.
    // This result uses the current user annotations and the adjusted delay.
    function displayTextgridResult() {
      const words = currentJsonData.words.sentence;
      const intervals = currentJsonData.words.interval;
      const disfluencyLabels = userWordAnnotationFlags.map(flag => flag ? 1 : 0);
      const resultData = {
        words: words,
        intervals: intervals,
        disfluency_label: disfluencyLabels,
        delayUsed: delay
      };
      const resultDiv = document.getElementById('textgrid-result');
      resultDiv.innerHTML = "<h3>Textgrid Result</h3><pre>" + JSON.stringify(resultData, null, 2) + "</pre>";
      resultDiv.style.display = "block";
    }
    
    // Save a JSON-like result for the current file.
    function saveTextgridResult() {
      const words = currentJsonData.words.sentence;
      const intervals = currentJsonData.words.interval;
      const disfluencyLabels = userWordAnnotationFlags.map(flag => flag ? 1 : 0);
      const resultData = {
        words: words,
        intervals: intervals,
        disfluency_label: disfluencyLabels,
        delayUsed: delay
      };
      resultsPerFile[idList[currentIndex]].textgridResult = JSON.stringify(resultData);
    }
    
    /***********************
     * Confirm Button (Enables Next)
     ***********************/
    document.getElementById('confirm-button').addEventListener('click', () => {
      const fileId = idList[currentIndex];
      resultsPerFile[fileId] = {
        predicted_method: currentJsonData.predicted_method || "",
        editorAnnotations: recordedIntervals,
        textgridResult: JSON.stringify({
          words: currentJsonData.words.sentence,
          intervals: currentJsonData.words.interval,
          disfluency_label: userWordAnnotationFlags.map(flag => flag ? 1 : 0),
          delayUsed: delay
        })
      };
      document.getElementById('next-page').disabled = false;
    });
    
    /***********************
     * Navigation & Save
     ***********************/
    document.getElementById('prev-page').addEventListener('click', () => {
      if (currentIndex > 0) {
        currentIndex--;
        loadCurrentFile();
      }
    });
    
    document.getElementById('next-page').addEventListener('click', () => {
      if (currentIndex < idList.length - 1) {
        currentIndex++;
        loadCurrentFile();
      }
    });
    
    document.getElementById('save-result').addEventListener('click', () => {
      const progressData = {
        raterName: raterName,
        currentIndex: currentIndex,
        resultsPerFile: resultsPerFile,
        globalShowMethodLabels: globalShowMethodLabels,
        globalShuffleMethods: globalShuffleMethods,
        globalSelectedMethods: globalSelectedMethods,
        delay: delay
      };
      localStorage.setItem(STORAGE_KEY, JSON.stringify(progressData));
      alert("Progress saved!");
    });
    
    document.getElementById('finish-button').addEventListener('click', () => {
      // New CSV includes a Delay column.
      let csvContent = "data:text/csv;charset=utf-8,";
      csvContent += "Rater,FileID,Predicted_Method,User_Annotations,Disfluency_Label,words,Delay\r\n";
      for (let fileId in resultsPerFile) {
        const res = resultsPerFile[fileId];
        const userAnnStr = (res.editorAnnotations || [])
          .map(ann => `[${ann.start.toFixed(2)}-${ann.end.toFixed(2)}]`)
          .join(" | ");
        let disfluencyLabel = "";
        let words = "";
        let delayUsed = "";
        if (res.textgridResult) {
          try {
            const obj = JSON.parse(res.textgridResult);
            disfluencyLabel = obj.disfluency_label.join(" ");
            words = obj.words.join(" ");
            delayUsed = obj.delayUsed !== undefined ? obj.delayUsed.toFixed(2) : "";
          } catch (error) {
            disfluencyLabel = "";
            words = "";
            delayUsed = "";
          }
        }
        csvContent += `${raterName},${fileId},${res.predicted_method},"${userAnnStr}","${disfluencyLabel}", "${words}", "${delayUsed}"\r\n`;
      }
      const encodedUri = encodeURI(csvContent);
      const link = document.createElement("a");
      link.setAttribute("href", encodedUri);
      link.setAttribute("download", `${raterName}_results_test_3.csv`);
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      localStorage.removeItem(STORAGE_KEY);
    });
    
    /***********************
     * Replay Button (if needed)
     ***********************/
    document.getElementById('replay-button') && document.getElementById('replay-button').addEventListener('click', () => {
      document.getElementById('draw-overlay').innerHTML = "";
      const wordOverlays = document.createElement('div');
      wordOverlays.id = "word-overlays";
      wordOverlays.style.position = "absolute";
      wordOverlays.style.top = "0";
      wordOverlays.style.left = "0";
      wordOverlays.style.width = "100%";
      wordOverlays.style.height = "100%";
      wordOverlays.style.pointerEvents = "none";
      document.getElementById('draw-overlay').appendChild(wordOverlays);
      
      recordedIntervals = [];
      document.getElementById('results').style.display = 'none';
      wavesurfer.stop();
      wavesurfer.play(0);
    });
    
    // (Space bar for play/pause is enabled globally)
  </script>
</body>
</html>